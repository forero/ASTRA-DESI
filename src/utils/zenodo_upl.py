import os
import json
import time
import shutil
import pathlib
import mimetypes
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any

import requests


@dataclass
class ZenodoConfig:
    token: str
    base_url: str = 'https://zenodo.org'
    timeout: int = 60
    retries: int = 3
    retry_backoff_s: float = 2.0

    @property
    def api(self) -> str:
        return f'{self.base_url}/api'


@dataclass
class Creator:
    name: str
    affiliation: Optional[str] = None
    orcid: Optional[str] = None

    def to_zenodo(self) -> Dict[str, Any]:
        out = {'name': self.name}
        if self.affiliation:
            out['affiliation'] = self.affiliation
        if self.orcid:
            out['orcid'] = self.orcid
        return out


@dataclass
class DepositionMeta:
    title: str
    upload_type: str = 'dataset'  # dataset, software, poster, ...
    description: str = 'Data products generated by ASTRA-DESI pipeline.'
    creators: List[Creator] = field(default_factory=list)
    keywords: List[str] = field(default_factory=lambda: ['ASTRA', 'DESI', 'cosmic web'])
    access_right: str = 'open'  # open, embargoed, restricted, closed
    license: str = 'cc-by-4.0'  # zenodo license id
    communities: Optional[List[str]] = None
    version: Optional[str] = None
    related_identifiers: Optional[List[Dict[str, str]]] = None  # like doi of a paper

    def to_zenodo(self) -> Dict[str, Any]:
        md = {
            'metadata': {
                'title': self.title,
                'upload_type': self.upload_type,
                'description': self.description,
                'creators': [c.to_zenodo() for c in self.creators] or [{'name': 'Unknown'}],
                'keywords': self.keywords,
                'access_right': self.access_right,
                'license': self.license,
            }
        }
        if self.communities:
            md['metadata']['communities'] = [{'identifier': c} for c in self.communities]
        if self.version:
            md['metadata']['version'] = self.version
        if self.related_identifiers:
            md['metadata']['related_identifiers'] = self.related_identifiers
        return md


class ZenodoUploader:
    def __init__(self, cfg: ZenodoConfig):
        self.cfg = cfg
        self.session = requests.Session()
        self.session.headers.update({'Authorization': f'Bearer {self.cfg.token}'})

    def _request(self, method: str, url: str, **kwargs):
        last_exc = None
        for attempt in range(1, self.cfg.retries + 1):
            try:
                resp = self.session.request(method, url, timeout=self.cfg.timeout, **kwargs)
                if resp.status_code >= 400:
                    # some transient errors (502/503/504) -> retry
                    if resp.status_code in (502, 503, 504) and attempt < self.cfg.retries:
                        time.sleep(self.cfg.retry_backoff_s * attempt)
                        continue
                return resp
            except requests.RequestException as exc:
                last_exc = exc
                if attempt < self.cfg.retries:
                    time.sleep(self.cfg.retry_backoff_s * attempt)
                else:
                    raise
        raise last_exc

    # zenodo api
    def create_deposition(self, meta: DepositionMeta) -> Dict[str, Any]:
        url = f'{self.cfg.api}/deposit/depositions'
        resp = self._request('POST', url, json=meta.to_zenodo())
        resp.raise_for_status()
        return resp.json()

    def get_deposition(self, deposition_id: int) -> Dict[str, Any]:
        url = f'{self.cfg.api}/deposit/depositions/{deposition_id}'
        resp = self._request('GET', url)
        resp.raise_for_status()
        return resp.json()

    def upload_file_via_bucket(self, bucket_url: str, filepath: str, dest_name: Optional[str] = None):
        filename = dest_name or os.path.basename(filepath)
        upload_url = f'{bucket_url}/{filename}'

        # guess a mime type, if none, requests will default to octet-stream
        mime, _ = mimetypes.guess_type(filename)
        with open(filepath, 'rb') as f:
            resp = self._request('PUT', upload_url, data=f, headers={'Content-Type': mime or 'application/octet-stream'})
        resp.raise_for_status()

    def publish(self, deposition_id: int):
        url = f'{self.cfg.api}/deposit/depositions/{deposition_id}/actions/publish'
        resp = self._request('POST', url)
        resp.raise_for_status()
        return resp.json()




def ensure_pscratch_copy(source_paths: List[str], pscratch_dir: str, keep_tree: bool = False,) -> List[str]:

    pscratch = pathlib.Path(pscratch_dir).expanduser().resolve()
    pscratch.mkdir(parents=True, exist_ok=True)
    dst_paths = []

    repo_root = pathlib.Path(__file__).resolve().parents[3] 
    # ASTRA-DESI root (src/utils/zenodo_uploader.py -> src/utils -> src -> ROOT)

    for src in source_paths:
        srcp = pathlib.Path(src).expanduser().resolve()
        if not srcp.exists():
            raise FileNotFoundError(f'Source not found: {srcp}')

        if keep_tree and repo_root in srcp.parents:
            rel = srcp.relative_to(repo_root)
            dst = pscratch / rel
            dst.parent.mkdir(parents=True, exist_ok=True)
        else:
            dst = pscratch / srcp.name

        if srcp.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(srcp, dst)
        else:
            shutil.copy2(srcp, dst)
        dst_paths.append(str(dst))
    return dst_paths


def push_to_zenodo(token: str, base_url: str, files_on_disk: List[str], title: str,
                   description: str, creators: List[Dict[str, str]],
                   keywords: Optional[List[str]] = None, access_right: str = 'open',
                   license_id: str = 'cc-by-4.0', communities: Optional[List[str]] = None,
                   publish: bool = False, version: Optional[str] = None,
                   related_identifiers: Optional[List[Dict[str, str]]] = None,) -> Dict[str, Any]:

    cfg = ZenodoConfig(token=token, base_url=base_url)
    up = ZenodoUploader(cfg)

    meta = DepositionMeta(title=title, description=description, creators=[Creator(**c) for c in creators],
                          keywords=keywords or ['ASTRA', 'DESI', 'cosmic web'], access_right=access_right,
                          license=license_id, communities=communities, version=version,
                          related_identifiers=related_identifiers)

    dep = up.create_deposition(meta)
    bucket = dep['links']['bucket']

    for fpath in files_on_disk:
        up.upload_file_via_bucket(bucket, fpath)

    if publish:
        dep = up.publish(dep['id'])

    return dep